import{S as g,n as A,g as T,d as i,P as I,c as _}from"./index-D4dQ38WE.js";import{A as d,g as R}from"./index-DFfaDUBv.js";import{c as P}from"./index-BImy_fb0.js";import"./prompts-CZcZabTo.js";class N{client=null;async initialize(){const e=await g.getBookmarkSiteApiUrl(),t=await g.getBookmarkSiteApiKey();if(!t)throw new d("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.");const a=A(e||T().BASE_URL);this.client=P({apiKey:t,baseUrl:a})}async ensureClient(){if(this.client||await this.initialize(),!this.client)throw new d("API_KEY_INVALID","Failed to initialize TMarks client");return this.client}async getTags(){const e=await this.ensureClient();try{return(await e.tags.getTags()).data.tags.map(a=>({name:a.name,color:a.color,count:a.bookmark_count||0,createdAt:new Date(a.created_at).getTime()}))}catch(t){throw t.code==="MISSING_API_KEY"?new d("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.",{originalError:t}):new d("BOOKMARK_SITE_ERROR",`Failed to fetch tags: ${t.message}`,{originalError:t})}}async getBookmarks(e,t=100){const a=await this.ensureClient();try{const o=await a.bookmarks.getBookmarks({page_size:t,page_cursor:e});return o.data.bookmarks.length?{bookmarks:o.data.bookmarks.map(n=>({url:n.url,title:n.title,description:n.description||"",tags:n.tags.map(c=>c.name),createdAt:new Date(n.created_at).getTime(),remoteId:n.id,isPublic:n.is_public})),hasMore:o.data.meta.has_more,nextCursor:o.data.meta.next_cursor}:{bookmarks:[],hasMore:!1,nextCursor:null}}catch(o){throw new d("BOOKMARK_SITE_ERROR",`Failed to fetch bookmarks: ${o.message}`,{originalError:o})}}async addBookmark(e){const t=await this.ensureClient();try{console.log("[BookmarkAPI] 保存书签:",e.title),console.log("[BookmarkAPI] 标签:",e.tags);const a=await t.bookmarks.createBookmark({title:e.title,url:e.url,description:e.description,cover_image:e.thumbnail,tags:e.tags,is_public:e.isPublic??!1});if(!a.data.bookmark)throw new d("BOOKMARK_SITE_ERROR","Failed to add bookmark: No data returned");return console.log("[BookmarkAPI] 书签创建成功, ID:",a.data.bookmark.id),{id:a.data.bookmark.id}}catch(a){throw new d("BOOKMARK_SITE_ERROR",`Failed to add bookmark: ${a.message}`,{originalError:a})}}async testConnection(){try{return await(await this.ensureClient()).user.getMe(),!0}catch(e){return console.error("API connection test failed:",e),!1}}}const f=new N;class M{contextCache=null;contextPromise=null;async recommendTags(e){try{const t=g.loadConfig(),a=this.getContext(),o=await t,r=o.aiConfig.apiKeys[o.aiConfig.provider];if(!r)return console.warn("[TagRecommender] No API key configured, using fallback"),this.fallbackRecommendation(e);const n=await a,c={page:{title:e.title,url:e.url,description:e.description,content:e.content?.substring(0,500)},context:n,options:{maxTags:o.preferences.maxSuggestedTags||5,preferExisting:!0}},l=o.aiConfig.apiUrls?.[o.aiConfig.provider],u=o.aiConfig.enableCustomPrompt?o.aiConfig.customPrompt:void 0,w=await this.callAIWithRetry(c,r,o.aiConfig.provider,o.aiConfig.model,l,u,1,void 0),m=n.existingTags,p=new Set(m.map(h=>h.trim().toLowerCase()));console.log("[TagRecommender] 开始修正 isNew 字段, 已有标签数量:",m.length),console.log("[TagRecommender] AI 返回的标签:",w.suggestedTags);const k=w.suggestedTags.map(h=>{const C=h.name.trim().toLowerCase(),x=p.has(C),B={...h,isNew:!x};return console.log(`[TagRecommender] 标签 "${h.name}": AI判断 isNew=${h.isNew}, 实际应为 isNew=${B.isNew}, 在已有标签中? ${x}`),B}),S=this.deduplicateAndSort(k);return console.log("[TagRecommender] 已修正 isNew 字段 (最终结果):",S),{tags:S,source:"ai",timestamp:Date.now()}}catch(t){console.error("[TagRecommender] AI recommendation failed:",t);const a=t instanceof Error?t.message:"AI recommendation failed";return this.fallbackRecommendation(e,a)}}async getContext(){if(this.contextCache)return this.contextCache;if(this.contextPromise)return this.contextPromise;this.contextPromise=this.loadContextFromDB();try{const e=await this.contextPromise;return this.contextCache=e,e}finally{this.contextPromise=null}}async callAIWithRetry(e,t,a,o,r,n,c,l){const u=R(a);let w;for(let m=0;m<c;m++)try{if(typeof l=="number"&&l>0){const k=new Promise((h,C)=>{setTimeout(()=>C(new Error("AI request timeout")),l)});return await Promise.race([u.generateTags(e,t,o,r,n),k])}return await u.generateTags(e,t,o,r,n)}catch(p){if(w=p,console.error(`[TagRecommender] AI call attempt ${m+1} failed:`,p),m<c-1){const k=Math.pow(2,m)*1e3;await this.delay(k)}}throw w||new Error("AI request failed after retries")}async fallbackRecommendation(e,t){console.log("[TagRecommender] ⚠️ Using fallback recommendation (AI failed)");const a=this.extractKeywords(e.title+" "+(e.description||"")),r=(await i.tags.toArray()).filter(n=>a.some(c=>n.name.toLowerCase().includes(c.toLowerCase())||c.toLowerCase().includes(n.name.toLowerCase()))).sort((n,c)=>(c.count||0)-(n.count||0)).slice(0,3).map(n=>({name:n.name,isNew:!1,confidence:.6}));return console.log("[TagRecommender] Fallback 返回的标签 (全部 isNew=false):",r),{tags:r,source:"fallback",timestamp:Date.now(),message:t||null}}extractKeywords(e){return e.split(/[\s\/\-_、，。！？]+/).map(t=>t.trim()).filter(t=>t.length>1).slice(0,20)}deduplicateAndSort(e){const t=new Set,a=[];for(const o of e){const r=o.name.toLowerCase().trim();t.has(r)||(t.add(r),a.push(o))}return a.sort((o,r)=>r.confidence-o.confidence)}delay(e){return new Promise(t=>setTimeout(t,e))}clearContextCache(){this.contextCache=null}async preloadContext(){if(this.contextPromise){await this.contextPromise;return}const e=this.loadContextFromDB(!0);this.contextPromise=e;try{const t=await e;this.contextCache=t}finally{this.contextPromise=null}}async refreshContextFromDB(){const e=this.loadContextFromDB(!0);this.contextPromise=e;try{const t=await e;this.contextCache=t}finally{this.contextPromise=null}}updateContextWithBookmark(e){if(!this.contextCache)return;const t=new Set(this.contextCache.existingTags.map(o=>o.toLowerCase())),a=[];for(const o of e.tags){const r=o.trim();r&&(t.has(r.toLowerCase())||(t.add(r.toLowerCase()),a.push(r)))}a.length>0&&(this.contextCache.existingTags=[...this.contextCache.existingTags,...a].slice(-200)),this.contextCache.recentBookmarks=[{title:e.title,tags:e.tags},...this.contextCache.recentBookmarks].slice(0,20)}async loadContextFromDB(e=!1){if(!e&&this.contextCache)return this.contextCache;const[t,a]=await Promise.all([i.tags.orderBy("count").reverse().limit(200).toArray().then(r=>r.map(n=>n.name)),i.bookmarks.orderBy("createdAt").reverse().limit(20).toArray().then(r=>r.map(n=>({title:n.title,tags:n.tags})))]),o={existingTags:t,recentBookmarks:a};return this.contextCache=o,o}}const y=new M;class U{async fullSync(){const e=Date.now();try{console.log("[CacheManager] Starting full sync...");const t=await f.getTags();await i.tags.clear(),await i.tags.bulkAdd(t),console.log(`[CacheManager] Synced ${t.length} tags`);let a,o=0,r=0;for(await i.bookmarks.clear();r<I.MAX_PAGES;){const{bookmarks:c,hasMore:l,nextCursor:u}=await f.getBookmarks(a,I.DEFAULT_PAGE_SIZE);if(c.length>0&&(await i.bookmarks.bulkAdd(c),o+=c.length,console.log(`[CacheManager] Synced batch ${r+1}: ${c.length} bookmarks`)),!l||!u)break;a=u,r++}await i.updateLastSyncTime(Date.now()),await i.metadata.put({key:"totalTags",value:t.length,updatedAt:Date.now()}),await i.metadata.put({key:"totalBookmarks",value:o,updatedAt:Date.now()}),await y.refreshContextFromDB();const n=Date.now()-e;return console.log(`[CacheManager] Full sync completed in ${n}ms`),{success:!0,duration:n,stats:{tags:t.length,bookmarks:o}}}catch(t){return console.error("[CacheManager] Full sync failed:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async incrementalSync(){try{return await i.getLastSyncTime()===0?this.fullSync():(console.log("[CacheManager] Incremental sync not implemented, falling back to full sync"),this.fullSync())}catch(e){return console.error("[CacheManager] Incremental sync failed:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async getStats(){return i.getStats()}async isCacheStale(e=24){const t=await i.getLastSyncTime();if(t===0)return!0;const a=e*60*60*1e3;return Date.now()-t>a}async autoSync(e=24){return await this.isCacheStale(e)?(console.log("[CacheManager] Cache is stale, performing auto sync"),this.incrementalSync()):(console.log("[CacheManager] Cache is fresh, skipping sync"),null)}async clearCache(){await i.clearAll(),y.clearContextCache(),console.log("[CacheManager] Cache cleared")}}const E=new U;class D{async captureScreenshot(){try{const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!e.id)throw new Error("No active tab found");const t=await chrome.tabs.captureVisibleTab({format:"png",quality:100});return console.log("[SnapshotService] Screenshot captured, size:",t.length),t}catch(e){throw console.error("[SnapshotService] Failed to capture screenshot:",e),new d("UNKNOWN_ERROR",`Failed to capture screenshot: ${e instanceof Error?e.message:"Unknown error"}`)}}async uploadSnapshot(e,t){try{const a=await g.getBookmarkSiteApiUrl(),o=await g.getBookmarkSiteApiKey();if(!o)throw new d("API_KEY_INVALID","API key is required to upload snapshots");const n=`${A(a||T().BASE_URL)}/bookmarks/${e}/snapshots`;console.log("[SnapshotService] Uploading snapshot to:",n);const c=await fetch(n,{method:"POST",headers:{"X-API-Key":o,"Content-Type":"application/json"},body:JSON.stringify({image:t})});if(!c.ok){const u=await c.json().catch(()=>({}));throw new Error(u.message||`HTTP error ${c.status}`)}const l=await c.json();return console.log("[SnapshotService] Snapshot uploaded successfully:",l),{success:!0,snapshotId:l.data?.snapshot?.id,version:l.data?.snapshot?.version}}catch(a){return console.error("[SnapshotService] Failed to upload snapshot:",a),{success:!1,error:a instanceof Error?a.message:"Failed to upload snapshot"}}}async captureAndUpload(e){const t=await this.captureScreenshot();return this.uploadSnapshot(e,t)}}const b=new D;class F{async shouldAutoSnapshot(){try{const e=await g.getBookmarkSiteApiUrl(),t=await g.getBookmarkSiteApiKey();if(!t)return!1;const a=A(e||T().BASE_URL);return(await P({apiKey:t,baseUrl:a}).user.getSnapshotSettings()).autoCreate}catch(e){return console.warn("[BookmarkService] Failed to check auto-snapshot setting:",e),!1}}async saveBookmark(e){try{const t=await f.addBookmark(e);return await i.bookmarks.add({url:e.url,title:e.title,description:e.description,tags:e.tags,createdAt:Date.now(),remoteId:t.id,isPublic:e.isPublic??!1}),await this.updateTagCounts(e.tags),y.updateContextWithBookmark({title:e.title,tags:e.tags}),await this.shouldAutoSnapshot()&&t.id&&(console.log("[BookmarkService] Auto-snapshot enabled, capturing..."),b.captureAndUpload(t.id).then(o=>{o.success?console.log("[BookmarkService] Auto-snapshot captured successfully:",o.snapshotId):console.warn("[BookmarkService] Auto-snapshot failed:",o.error)}).catch(o=>{console.warn("[BookmarkService] Auto-snapshot error:",o)})),{success:!0,bookmarkId:t.id}}catch(t){if(console.error("[BookmarkService] Failed to save bookmark:",t),t.message&&t.message.includes("URL already exists"))return{success:!1,error:"该网址已经被收藏过了",message:"该网址已经被收藏过了"};if(t instanceof Error&&t.message.includes("Network"))return await this.queueForLaterSync(e),{success:!0,offline:!0,message:"已暂存,将在网络恢复后同步"};throw t}}async updateTagCounts(e){for(const t of e){const a=await i.tags.where("name").equals(t).first();a&&a.id?await i.tags.update(a.id,{count:(a.count||0)+1}):await i.tags.add({name:t,count:1,createdAt:Date.now()})}}async queueForLaterSync(e){await i.metadata.add({key:`pending_${Date.now()}`,value:e,updatedAt:Date.now()}),console.log("[BookmarkService] Bookmark queued for later sync")}async syncPendingBookmarks(){const e=await i.metadata.where("key").startsWith("pending_").toArray();let t=0;for(const a of e)try{await f.addBookmark(a.value),await i.metadata.delete(a.key),t++,console.log("[BookmarkService] Synced pending bookmark:",a.value.title)}catch(o){console.error("[BookmarkService] Failed to sync pending bookmark:",o)}return console.log(`[BookmarkService] Synced ${t}/${e.length} pending bookmarks`),t}async getPendingCount(){return await i.metadata.where("key").startsWith("pending_").count()}}const v=new F;console.log("[Background] Service worker started");y.preloadContext().catch(s=>{console.error("[Background] Failed to preload AI context:",s)});chrome.runtime.onInstalled.addListener(async s=>{console.log("[Background] Extension installed:",s.reason),s.reason==="install"?console.log("[Background] First time install"):s.reason==="update"&&console.log("[Background] Extension updated")});function L(){const s=new Date,e=new Date(s);return e.setHours(23,0,0,0),e<=s&&e.setDate(e.getDate()+1),e.getTime()-s.getTime()}async function K(){try{const s=await g.loadConfig();if(!s.preferences.autoSync)return;console.log("[Background] Running scheduled auto-sync (23:00)...");const e=await E.autoSync(s.preferences.syncInterval);e&&console.log("[Background] Auto-sync result:",e)}catch(s){console.error("[Background] Auto-sync failed:",s)}}async function O(){const s=()=>{const e=L();console.log("[Background] Next auto-sync scheduled in",Math.round(e/1e3),"seconds"),setTimeout(async()=>{await K(),s()},e)};s()}O().catch(console.error);v.syncPendingBookmarks().catch(console.error);chrome.runtime.onMessage.addListener((s,e,t)=>($(s).then(a=>t(a)).catch(a=>{console.error("[Background] Message handler error:",a),t({success:!1,error:a instanceof Error?a.message:"Unknown error"})}),!0));async function $(s,e){switch(console.log("[Background] Received message:",s.type),s.type){case"EXTRACT_PAGE_INFO":{const[t]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!t.id)throw new Error("No active tab");try{return await chrome.tabs.sendMessage(t.id,s)}catch(a){console.error("[Background] Failed to send message to content script:",a);try{return await chrome.scripting.executeScript({target:{tabId:t.id},files:["assets/content.js"]}),await new Promise(r=>setTimeout(r,100)),await Promise.race([chrome.tabs.sendMessage(t.id,s),new Promise((r,n)=>setTimeout(()=>n(new Error("Message timeout")),_.CONTENT_SCRIPT_INJECTION))])}catch(o){console.error("[Background] Failed to inject content script:",o);try{const r=await chrome.tabs.get(t.id),n=r.url||"";return{success:!0,data:{title:r.title||"Untitled",url:n,description:"",content:"",thumbnail:""}}}catch{throw new Error("Failed to extract page info: Unable to access tab information")}}}}case"RECOMMEND_TAGS":{const t=s.payload;return{success:!0,data:await y.recommendTags(t)}}case"SAVE_BOOKMARK":{const t=s.payload;return{success:!0,data:await v.saveBookmark(t)}}case"SYNC_CACHE":{const t=await E.fullSync();return{success:t.success,data:t,error:t.error}}case"GET_EXISTING_TAGS":try{return{success:!0,data:await f.getTags()}}catch(t){return console.error("[Background] Failed to get existing tags:",t),{success:!1,error:t instanceof Error?t.message:"Failed to load tags"}}case"GET_CONFIG":return{success:!0,data:await g.loadConfig()};case"CAPTURE_SNAPSHOT":{const{bookmarkId:t}=s.payload;if(!t)return{success:!1,error:"Bookmark ID is required"};const a=await b.captureAndUpload(t);return{success:a.success,data:a.success?{snapshotId:a.snapshotId,version:a.version}:void 0,error:a.error}}default:throw new Error(`Unknown message type: ${s.type}`)}}chrome.action.onClicked.addListener(async s=>{console.log("[Background] Extension icon clicked for tab:",s.id)});console.log("[Background] Service worker initialized");
