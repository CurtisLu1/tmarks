import{S as f,g as I,d as i,P as B,c as E}from"./index-Dr3hl5Cz.js";import{A as w,g as _}from"./index-CwAni-Hp.js";import{c as R}from"./index-ClstaeQk.js";import"./prompts-CZcZabTo.js";class b{client=null;async initialize(){const e=await f.getBookmarkSiteApiUrl(),t=await f.getBookmarkSiteApiKey();if(!t)throw new w("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.");let a;e?e.endsWith("/api")?a=e:a=I(e).API_BASE:a=I().API_BASE,this.client=R({apiKey:t,baseUrl:a})}async ensureClient(){if(this.client||await this.initialize(),!this.client)throw new w("API_KEY_INVALID","Failed to initialize TMarks client");return this.client}async getTags(){const e=await this.ensureClient();try{return(await e.tags.getTags()).data.tags.map(a=>({name:a.name,color:a.color,count:a.bookmark_count||0,createdAt:new Date(a.created_at).getTime()}))}catch(t){throw t.code==="MISSING_API_KEY"?new w("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.",{originalError:t}):new w("BOOKMARK_SITE_ERROR",`Failed to fetch tags: ${t.message}`,{originalError:t})}}async getBookmarks(e=1,t=100){const a=await this.ensureClient();try{const o=await a.bookmarks.getBookmarks({page_size:t,page_cursor:e>1?`page_${e}`:void 0});return o.data.bookmarks.length?{bookmarks:o.data.bookmarks.map(s=>({url:s.url,title:s.title,description:s.description||"",tags:s.tags.map(c=>c.name),createdAt:new Date(s.created_at).getTime(),remoteId:s.id,isPublic:s.is_public})),hasMore:o.data.meta.has_more}:{bookmarks:[],hasMore:!1}}catch(o){throw new w("BOOKMARK_SITE_ERROR",`Failed to fetch bookmarks: ${o.message}`,{originalError:o})}}async addBookmark(e){const t=await this.ensureClient();try{let a=[];if(e.tags&&e.tags.length>0){console.log("[BookmarkAPI] 处理标签:",e.tags);const s=(await t.tags.getTags()).data.tags;console.log("[BookmarkAPI] 已有标签数量:",s.length);for(const c of e.tags){const d=s.find(l=>l.name.toLowerCase()===c.toLowerCase());if(d)console.log(`[BookmarkAPI] 标签 "${c}" 已存在, ID: ${d.id}`),a.push(d.id);else{console.log(`[BookmarkAPI] 标签 "${c}" 不存在，正在创建...`);try{const l=await t.tags.createTag({name:c}),u=l.data.tag.id;console.log(`[BookmarkAPI] 标签 "${c}" 创建成功, ID: ${u}`),a.push(u),s.push(l.data.tag)}catch(l){if(l.code==="DUPLICATE_TAG"){console.log(`[BookmarkAPI] 标签 "${c}" 已被并发创建，重新查找...`);const g=(await t.tags.getTags()).data.tags.find(m=>m.name.toLowerCase()===c.toLowerCase());if(g)a.push(g.id),console.log(`[BookmarkAPI] 重新找到标签 "${c}", ID: ${g.id}`);else throw console.error(`[BookmarkAPI] 无法创建或找到标签 "${c}"`),l}else throw console.error(`[BookmarkAPI] 创建标签 "${c}" 失败:`,l),l}}}console.log("[BookmarkAPI] 最终标签 IDs:",a)}const o=await t.bookmarks.createBookmark({title:e.title,url:e.url,description:e.description,cover_image:e.thumbnail,tag_ids:a,is_public:e.isPublic??!1});if(!o.data.bookmark)throw new w("BOOKMARK_SITE_ERROR","Failed to add bookmark: No data returned");return console.log("[BookmarkAPI] 书签创建成功, ID:",o.data.bookmark.id),{id:o.data.bookmark.id}}catch(a){throw new w("BOOKMARK_SITE_ERROR",`Failed to add bookmark: ${a.message}`,{originalError:a})}}async testConnection(){try{return await(await this.ensureClient()).user.getMe(),!0}catch(e){return console.error("API connection test failed:",e),!1}}}const y=new b;class M{contextCache=null;contextPromise=null;async recommendTags(e){try{const t=f.loadConfig(),a=this.getContext(),o=await t,r=o.aiConfig.apiKeys[o.aiConfig.provider];if(!r)return console.warn("[TagRecommender] No API key configured, using fallback"),this.fallbackRecommendation(e);const s=await a,c={page:{title:e.title,url:e.url,description:e.description,content:e.content?.substring(0,500)},context:s,options:{maxTags:o.preferences.maxSuggestedTags||5,preferExisting:!0}},d=o.aiConfig.apiUrls?.[o.aiConfig.provider],l=o.aiConfig.enableCustomPrompt?o.aiConfig.customPrompt:void 0,u=await this.callAIWithRetry(c,r,o.aiConfig.provider,o.aiConfig.model,d,l,1,void 0),g=s.existingTags,m=new Set(g.map(h=>h.trim().toLowerCase()));console.log("[TagRecommender] 开始修正 isNew 字段, 已有标签数量:",g.length),console.log("[TagRecommender] AI 返回的标签:",u.suggestedTags);const k=u.suggestedTags.map(h=>{const T=h.name.trim().toLowerCase(),A=m.has(T),x={...h,isNew:!A};return console.log(`[TagRecommender] 标签 "${h.name}": AI判断 isNew=${h.isNew}, 实际应为 isNew=${x.isNew}, 在已有标签中? ${A}`),x}),C=this.deduplicateAndSort(k);return console.log("[TagRecommender] 已修正 isNew 字段 (最终结果):",C),{tags:C,source:"ai",timestamp:Date.now()}}catch(t){console.error("[TagRecommender] AI recommendation failed:",t);const a=t instanceof Error?t.message:"AI recommendation failed";return this.fallbackRecommendation(e,a)}}async getContext(){if(this.contextCache)return this.contextCache;if(this.contextPromise)return this.contextPromise;this.contextPromise=this.loadContextFromDB();try{const e=await this.contextPromise;return this.contextCache=e,e}finally{this.contextPromise=null}}async callAIWithRetry(e,t,a,o,r,s,c,d){const l=_(a);let u;for(let g=0;g<c;g++)try{if(typeof d=="number"&&d>0){const k=new Promise((h,T)=>{setTimeout(()=>T(new Error("AI request timeout")),d)});return await Promise.race([l.generateTags(e,t,o,r,s),k])}return await l.generateTags(e,t,o,r,s)}catch(m){if(u=m,console.error(`[TagRecommender] AI call attempt ${g+1} failed:`,m),g<c-1){const k=Math.pow(2,g)*1e3;await this.delay(k)}}throw u||new Error("AI request failed after retries")}async fallbackRecommendation(e,t){console.log("[TagRecommender] ⚠️ Using fallback recommendation (AI failed)");const a=this.extractKeywords(e.title+" "+(e.description||"")),r=(await i.tags.toArray()).filter(s=>a.some(c=>s.name.toLowerCase().includes(c.toLowerCase())||c.toLowerCase().includes(s.name.toLowerCase()))).sort((s,c)=>(c.count||0)-(s.count||0)).slice(0,3).map(s=>({name:s.name,isNew:!1,confidence:.6}));return console.log("[TagRecommender] Fallback 返回的标签 (全部 isNew=false):",r),{tags:r,source:"fallback",timestamp:Date.now(),message:t||null}}extractKeywords(e){return e.split(/[\s\/\-_、，。！？]+/).map(t=>t.trim()).filter(t=>t.length>1).slice(0,20)}deduplicateAndSort(e){const t=new Set,a=[];for(const o of e){const r=o.name.toLowerCase().trim();t.has(r)||(t.add(r),a.push(o))}return a.sort((o,r)=>r.confidence-o.confidence)}delay(e){return new Promise(t=>setTimeout(t,e))}clearContextCache(){this.contextCache=null}async preloadContext(){if(this.contextPromise){await this.contextPromise;return}const e=this.loadContextFromDB(!0);this.contextPromise=e;try{const t=await e;this.contextCache=t}finally{this.contextPromise=null}}async refreshContextFromDB(){const e=this.loadContextFromDB(!0);this.contextPromise=e;try{const t=await e;this.contextCache=t}finally{this.contextPromise=null}}updateContextWithBookmark(e){if(!this.contextCache)return;const t=new Set(this.contextCache.existingTags.map(o=>o.toLowerCase())),a=[];for(const o of e.tags){const r=o.trim();r&&(t.has(r.toLowerCase())||(t.add(r.toLowerCase()),a.push(r)))}a.length>0&&(this.contextCache.existingTags=[...this.contextCache.existingTags,...a].slice(-200)),this.contextCache.recentBookmarks=[{title:e.title,tags:e.tags},...this.contextCache.recentBookmarks].slice(0,20)}async loadContextFromDB(e=!1){if(!e&&this.contextCache)return this.contextCache;const[t,a]=await Promise.all([i.tags.orderBy("count").reverse().limit(200).toArray().then(r=>r.map(s=>s.name)),i.bookmarks.orderBy("createdAt").reverse().limit(20).toArray().then(r=>r.map(s=>({title:s.title,tags:s.tags})))]),o={existingTags:t,recentBookmarks:a};return this.contextCache=o,o}}const p=new M;class D{async fullSync(){const e=Date.now();try{console.log("[CacheManager] Starting full sync...");const t=await y.getTags();await i.tags.clear(),await i.tags.bulkAdd(t),console.log(`[CacheManager] Synced ${t.length} tags`);let a=1,o=0;for(await i.bookmarks.clear();a<=B.MAX_PAGES;){const{bookmarks:s,hasMore:c}=await y.getBookmarks(a,B.DEFAULT_PAGE_SIZE);if(s.length>0&&(await i.bookmarks.bulkAdd(s),o+=s.length,console.log(`[CacheManager] Synced page ${a}: ${s.length} bookmarks`)),!c)break;a++}await i.updateLastSyncTime(Date.now()),await i.metadata.put({key:"totalTags",value:t.length,updatedAt:Date.now()}),await i.metadata.put({key:"totalBookmarks",value:o,updatedAt:Date.now()}),await p.refreshContextFromDB();const r=Date.now()-e;return console.log(`[CacheManager] Full sync completed in ${r}ms`),{success:!0,duration:r,stats:{tags:t.length,bookmarks:o}}}catch(t){return console.error("[CacheManager] Full sync failed:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async incrementalSync(){try{return await i.getLastSyncTime()===0?this.fullSync():(console.log("[CacheManager] Incremental sync not implemented, falling back to full sync"),this.fullSync())}catch(e){return console.error("[CacheManager] Incremental sync failed:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async getStats(){return i.getStats()}async isCacheStale(e=24){const t=await i.getLastSyncTime();if(t===0)return!0;const a=e*60*60*1e3;return Date.now()-t>a}async autoSync(e=24){return await this.isCacheStale(e)?(console.log("[CacheManager] Cache is stale, performing auto sync"),this.incrementalSync()):(console.log("[CacheManager] Cache is fresh, skipping sync"),null)}async clearCache(){await i.clearAll(),p.clearContextCache(),console.log("[CacheManager] Cache cleared")}}const S=new D;class N{async saveBookmark(e){try{const t=await y.addBookmark(e);return await i.bookmarks.add({url:e.url,title:e.title,description:e.description,tags:e.tags,createdAt:Date.now(),remoteId:t.id,isPublic:e.isPublic??!1}),await this.updateTagCounts(e.tags),p.updateContextWithBookmark({title:e.title,tags:e.tags}),{success:!0,bookmarkId:t.id}}catch(t){if(console.error("[BookmarkService] Failed to save bookmark:",t),t.message&&t.message.includes("URL already exists"))return{success:!1,error:"该网址已经被收藏过了",message:"该网址已经被收藏过了"};if(t instanceof Error&&t.message.includes("Network"))return await this.queueForLaterSync(e),{success:!0,offline:!0,message:"已暂存,将在网络恢复后同步"};throw t}}async updateTagCounts(e){for(const t of e){const a=await i.tags.where("name").equals(t).first();a&&a.id?await i.tags.update(a.id,{count:(a.count||0)+1}):await i.tags.add({name:t,count:1,createdAt:Date.now()})}}async queueForLaterSync(e){await i.metadata.add({key:`pending_${Date.now()}`,value:e,updatedAt:Date.now()}),console.log("[BookmarkService] Bookmark queued for later sync")}async syncPendingBookmarks(){const e=await i.metadata.where("key").startsWith("pending_").toArray();let t=0;for(const a of e)try{await y.addBookmark(a.value),await i.metadata.delete(a.key),t++,console.log("[BookmarkService] Synced pending bookmark:",a.value.title)}catch(o){console.error("[BookmarkService] Failed to sync pending bookmark:",o)}return console.log(`[BookmarkService] Synced ${t}/${e.length} pending bookmarks`),t}async getPendingCount(){return await i.metadata.where("key").startsWith("pending_").count()}}const P=new N;console.log("[Background] Service worker started");p.preloadContext().catch(n=>{console.error("[Background] Failed to preload AI context:",n)});chrome.runtime.onInstalled.addListener(async n=>{console.log("[Background] Extension installed:",n.reason),n.reason==="install"?console.log("[Background] First time install"):n.reason==="update"&&console.log("[Background] Extension updated")});function v(){const n=new Date,e=new Date(n);return e.setHours(23,0,0,0),e<=n&&e.setDate(e.getDate()+1),e.getTime()-n.getTime()}async function F(){try{const n=await f.loadConfig();if(!n.preferences.autoSync)return;console.log("[Background] Running scheduled auto-sync (23:00)...");const e=await S.autoSync(n.preferences.syncInterval);e&&console.log("[Background] Auto-sync result:",e)}catch(n){console.error("[Background] Auto-sync failed:",n)}}async function L(){const n=()=>{const e=v();console.log("[Background] Next auto-sync scheduled in",Math.round(e/1e3),"seconds"),setTimeout(async()=>{await F(),n()},e)};n()}L().catch(console.error);P.syncPendingBookmarks().catch(console.error);chrome.runtime.onMessage.addListener((n,e,t)=>($(n).then(a=>t(a)).catch(a=>{console.error("[Background] Message handler error:",a),t({success:!1,error:a instanceof Error?a.message:"Unknown error"})}),!0));async function $(n,e){switch(console.log("[Background] Received message:",n.type),n.type){case"EXTRACT_PAGE_INFO":{const[t]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!t.id)throw new Error("No active tab");try{return await chrome.tabs.sendMessage(t.id,n)}catch(a){console.error("[Background] Failed to send message to content script:",a);try{return await chrome.scripting.executeScript({target:{tabId:t.id},files:["assets/content.js"]}),await new Promise(r=>setTimeout(r,100)),await Promise.race([chrome.tabs.sendMessage(t.id,n),new Promise((r,s)=>setTimeout(()=>s(new Error("Message timeout")),E.CONTENT_SCRIPT_INJECTION))])}catch(o){console.error("[Background] Failed to inject content script:",o);try{const r=await chrome.tabs.get(t.id),s=r.url||"";return{success:!0,data:{title:r.title||"Untitled",url:s,description:"",content:"",thumbnail:""}}}catch{throw new Error("Failed to extract page info: Unable to access tab information")}}}}case"RECOMMEND_TAGS":{const t=n.payload;return{success:!0,data:await p.recommendTags(t)}}case"SAVE_BOOKMARK":{const t=n.payload;return{success:!0,data:await P.saveBookmark(t)}}case"SYNC_CACHE":{const t=await S.fullSync();return{success:t.success,data:t,error:t.error}}case"GET_EXISTING_TAGS":try{return{success:!0,data:await y.getTags()}}catch(t){return console.error("[Background] Failed to get existing tags:",t),{success:!1,error:t instanceof Error?t.message:"Failed to load tags"}}case"GET_CONFIG":return{success:!0,data:await f.loadConfig()};default:throw new Error(`Unknown message type: ${n.type}`)}}chrome.action.onClicked.addListener(async n=>{console.log("[Background] Extension icon clicked for tab:",n.id)});console.log("[Background] Service worker initialized");
