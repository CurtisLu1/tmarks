import{S as g,n as A,g as T,d as i,P as I,c as v}from"./index-D4dQ38WE.js";import{A as d,g as R}from"./index-DFfaDUBv.js";import{c as b}from"./index-DX7QVYQb.js";import"./prompts-CZcZabTo.js";class N{client=null;async initialize(){const t=await g.getBookmarkSiteApiUrl(),e=await g.getBookmarkSiteApiKey();if(!e)throw new d("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.");const o=A(t||T().BASE_URL);this.client=b({apiKey:e,baseUrl:o})}async ensureClient(){if(this.client||await this.initialize(),!this.client)throw new d("API_KEY_INVALID","Failed to initialize TMarks client");return this.client}async getTags(){const t=await this.ensureClient();try{return(await t.tags.getTags()).data.tags.map(o=>({name:o.name,color:o.color,count:o.bookmark_count||0,createdAt:new Date(o.created_at).getTime()}))}catch(e){throw e.code==="MISSING_API_KEY"?new d("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.",{originalError:e}):new d("BOOKMARK_SITE_ERROR",`Failed to fetch tags: ${e.message}`,{originalError:e})}}async getBookmarks(t,e=100){const o=await this.ensureClient();try{const a=await o.bookmarks.getBookmarks({page_size:e,page_cursor:t});return a.data.bookmarks.length?{bookmarks:a.data.bookmarks.map(n=>({url:n.url,title:n.title,description:n.description||"",tags:n.tags.map(c=>c.name),createdAt:new Date(n.created_at).getTime(),remoteId:n.id,isPublic:n.is_public})),hasMore:a.data.meta.has_more,nextCursor:a.data.meta.next_cursor}:{bookmarks:[],hasMore:!1,nextCursor:null}}catch(a){throw new d("BOOKMARK_SITE_ERROR",`Failed to fetch bookmarks: ${a.message}`,{originalError:a})}}async addBookmark(t){const e=await this.ensureClient();try{console.log("[BookmarkAPI] 保存书签:",t.title),console.log("[BookmarkAPI] 标签:",t.tags);const o=await e.bookmarks.createBookmark({title:t.title,url:t.url,description:t.description,cover_image:t.thumbnail,tags:t.tags,is_public:t.isPublic??!1});if(!o.data.bookmark)throw new d("BOOKMARK_SITE_ERROR","Failed to add bookmark: No data returned");return console.log("[BookmarkAPI] 书签创建成功, ID:",o.data.bookmark.id),{id:o.data.bookmark.id}}catch(o){throw new d("BOOKMARK_SITE_ERROR",`Failed to add bookmark: ${o.message}`,{originalError:o})}}async testConnection(){try{return await(await this.ensureClient()).user.getMe(),!0}catch(t){return console.error("API connection test failed:",t),!1}}async findBookmarkByUrl(t){try{const o=await(await this.ensureClient()).bookmarks.findBookmarkByUrl(t);return o?{id:o.id,title:o.title}:null}catch(e){return console.error("[BookmarkAPI] Failed to find bookmark by URL:",e),null}}}const k=new N;class U{contextCache=null;contextPromise=null;async recommendTags(t){try{const e=g.loadConfig(),o=this.getContext(),a=await e,s=a.aiConfig.apiKeys[a.aiConfig.provider];if(!s)return console.warn("[TagRecommender] No API key configured, using fallback"),this.fallbackRecommendation(t);const n=await o,c={page:{title:t.title,url:t.url,description:t.description,content:t.content?.substring(0,500)},context:n,options:{maxTags:a.preferences.maxSuggestedTags||5,preferExisting:!0}},l=a.aiConfig.apiUrls?.[a.aiConfig.provider],u=a.aiConfig.enableCustomPrompt?a.aiConfig.customPrompt:void 0,w=await this.callAIWithRetry(c,s,a.aiConfig.provider,a.aiConfig.model,l,u,1,void 0),m=n.existingTags,p=new Set(m.map(h=>h.trim().toLowerCase()));console.log("[TagRecommender] 开始修正 isNew 字段, 已有标签数量:",m.length),console.log("[TagRecommender] AI 返回的标签:",w.suggestedTags);const f=w.suggestedTags.map(h=>{const C=h.name.trim().toLowerCase(),x=p.has(C),B={...h,isNew:!x};return console.log(`[TagRecommender] 标签 "${h.name}": AI判断 isNew=${h.isNew}, 实际应为 isNew=${B.isNew}, 在已有标签中? ${x}`),B}),S=this.deduplicateAndSort(f);return console.log("[TagRecommender] 已修正 isNew 字段 (最终结果):",S),{tags:S,source:"ai",timestamp:Date.now()}}catch(e){console.error("[TagRecommender] AI recommendation failed:",e);const o=e instanceof Error?e.message:"AI recommendation failed";return this.fallbackRecommendation(t,o)}}async getContext(){if(this.contextCache)return this.contextCache;if(this.contextPromise)return this.contextPromise;this.contextPromise=this.loadContextFromDB();try{const t=await this.contextPromise;return this.contextCache=t,t}finally{this.contextPromise=null}}async callAIWithRetry(t,e,o,a,s,n,c,l){const u=R(o);let w;for(let m=0;m<c;m++)try{if(typeof l=="number"&&l>0){const f=new Promise((h,C)=>{setTimeout(()=>C(new Error("AI request timeout")),l)});return await Promise.race([u.generateTags(t,e,a,s,n),f])}return await u.generateTags(t,e,a,s,n)}catch(p){if(w=p,console.error(`[TagRecommender] AI call attempt ${m+1} failed:`,p),m<c-1){const f=Math.pow(2,m)*1e3;await this.delay(f)}}throw w||new Error("AI request failed after retries")}async fallbackRecommendation(t,e){console.log("[TagRecommender] ⚠️ Using fallback recommendation (AI failed)");const o=this.extractKeywords(t.title+" "+(t.description||"")),s=(await i.tags.toArray()).filter(n=>o.some(c=>n.name.toLowerCase().includes(c.toLowerCase())||c.toLowerCase().includes(n.name.toLowerCase()))).sort((n,c)=>(c.count||0)-(n.count||0)).slice(0,3).map(n=>({name:n.name,isNew:!1,confidence:.6}));return console.log("[TagRecommender] Fallback 返回的标签 (全部 isNew=false):",s),{tags:s,source:"fallback",timestamp:Date.now(),message:e||null}}extractKeywords(t){return t.split(/[\s\/\-_、，。！？]+/).map(e=>e.trim()).filter(e=>e.length>1).slice(0,20)}deduplicateAndSort(t){const e=new Set,o=[];for(const a of t){const s=a.name.toLowerCase().trim();e.has(s)||(e.add(s),o.push(a))}return o.sort((a,s)=>s.confidence-a.confidence)}delay(t){return new Promise(e=>setTimeout(e,t))}clearContextCache(){this.contextCache=null}async preloadContext(){if(this.contextPromise){await this.contextPromise;return}const t=this.loadContextFromDB(!0);this.contextPromise=t;try{const e=await t;this.contextCache=e}finally{this.contextPromise=null}}async refreshContextFromDB(){const t=this.loadContextFromDB(!0);this.contextPromise=t;try{const e=await t;this.contextCache=e}finally{this.contextPromise=null}}updateContextWithBookmark(t){if(!this.contextCache)return;const e=new Set(this.contextCache.existingTags.map(a=>a.toLowerCase())),o=[];for(const a of t.tags){const s=a.trim();s&&(e.has(s.toLowerCase())||(e.add(s.toLowerCase()),o.push(s)))}o.length>0&&(this.contextCache.existingTags=[...this.contextCache.existingTags,...o].slice(-200)),this.contextCache.recentBookmarks=[{title:t.title,tags:t.tags},...this.contextCache.recentBookmarks].slice(0,20)}async loadContextFromDB(t=!1){if(!t&&this.contextCache)return this.contextCache;const[e,o]=await Promise.all([i.tags.orderBy("count").reverse().limit(200).toArray().then(s=>s.map(n=>n.name)),i.bookmarks.orderBy("createdAt").reverse().limit(20).toArray().then(s=>s.map(n=>({title:n.title,tags:n.tags})))]),a={existingTags:e,recentBookmarks:o};return this.contextCache=a,a}}const y=new U;class M{async fullSync(){const t=Date.now();try{console.log("[CacheManager] Starting full sync...");const e=await k.getTags();await i.tags.clear(),await i.tags.bulkAdd(e),console.log(`[CacheManager] Synced ${e.length} tags`);let o,a=0,s=0;for(await i.bookmarks.clear();s<I.MAX_PAGES;){const{bookmarks:c,hasMore:l,nextCursor:u}=await k.getBookmarks(o,I.DEFAULT_PAGE_SIZE);if(c.length>0&&(await i.bookmarks.bulkAdd(c),a+=c.length,console.log(`[CacheManager] Synced batch ${s+1}: ${c.length} bookmarks`)),!l||!u)break;o=u,s++}await i.updateLastSyncTime(Date.now()),await i.metadata.put({key:"totalTags",value:e.length,updatedAt:Date.now()}),await i.metadata.put({key:"totalBookmarks",value:a,updatedAt:Date.now()}),await y.refreshContextFromDB();const n=Date.now()-t;return console.log(`[CacheManager] Full sync completed in ${n}ms`),{success:!0,duration:n,stats:{tags:e.length,bookmarks:a}}}catch(e){return console.error("[CacheManager] Full sync failed:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async incrementalSync(){try{return await i.getLastSyncTime()===0?this.fullSync():(console.log("[CacheManager] Incremental sync not implemented, falling back to full sync"),this.fullSync())}catch(t){return console.error("[CacheManager] Incremental sync failed:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async getStats(){return i.getStats()}async isCacheStale(t=24){const e=await i.getLastSyncTime();if(e===0)return!0;const o=t*60*60*1e3;return Date.now()-e>o}async autoSync(t=24){return await this.isCacheStale(t)?(console.log("[CacheManager] Cache is stale, performing auto sync"),this.incrementalSync()):(console.log("[CacheManager] Cache is fresh, skipping sync"),null)}async clearCache(){await i.clearAll(),y.clearContextCache(),console.log("[CacheManager] Cache cleared")}}const E=new M;class D{async captureScreenshot(){try{const[t]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!t.id)throw new Error("No active tab found");const e=await chrome.tabs.captureVisibleTab({format:"png",quality:100});return console.log("[SnapshotService] Screenshot captured, size:",e.length),e}catch(t){throw console.error("[SnapshotService] Failed to capture screenshot:",t),new d("UNKNOWN_ERROR",`Failed to capture screenshot: ${t instanceof Error?t.message:"Unknown error"}`)}}async uploadSnapshot(t,e){try{const o=await g.getBookmarkSiteApiUrl(),a=await g.getBookmarkSiteApiKey();if(!a)throw new d("API_KEY_INVALID","API key is required to upload snapshots");const n=`${A(o||T().BASE_URL)}/bookmarks/${t}/snapshots`;console.log("[SnapshotService] Uploading snapshot to:",n);const c=await fetch(n,{method:"POST",headers:{"X-API-Key":a,"Content-Type":"application/json"},body:JSON.stringify({image:e})});if(!c.ok){const u=await c.json().catch(()=>({}));throw new Error(u.message||`HTTP error ${c.status}`)}const l=await c.json();return console.log("[SnapshotService] Snapshot uploaded successfully:",l),{success:!0,snapshotId:l.data?.snapshot?.id,version:l.data?.snapshot?.version}}catch(o){return console.error("[SnapshotService] Failed to upload snapshot:",o),{success:!1,error:o instanceof Error?o.message:"Failed to upload snapshot"}}}async captureAndUpload(t){const e=await this.captureScreenshot();return this.uploadSnapshot(t,e)}}const P=new D;class F{async shouldAutoSnapshot(){try{const t=await g.getBookmarkSiteApiUrl(),e=await g.getBookmarkSiteApiKey();if(!e)return!1;const o=A(t||T().BASE_URL);return(await b({apiKey:e,baseUrl:o}).user.getSnapshotSettings()).autoCreate}catch(t){return console.warn("[BookmarkService] Failed to check auto-snapshot setting:",t),!1}}async saveBookmark(t){try{const e=await k.addBookmark(t);return await i.bookmarks.add({url:t.url,title:t.title,description:t.description,tags:t.tags,createdAt:Date.now(),remoteId:e.id,isPublic:t.isPublic??!1}),await this.updateTagCounts(t.tags),y.updateContextWithBookmark({title:t.title,tags:t.tags}),await this.shouldAutoSnapshot()&&e.id&&(console.log("[BookmarkService] Auto-snapshot enabled, capturing..."),P.captureAndUpload(e.id).then(a=>{a.success?console.log("[BookmarkService] Auto-snapshot captured successfully:",a.snapshotId):console.warn("[BookmarkService] Auto-snapshot failed:",a.error)}).catch(a=>{console.warn("[BookmarkService] Auto-snapshot error:",a)})),{success:!0,bookmarkId:e.id}}catch(e){if(console.error("[BookmarkService] Failed to save bookmark:",e),e.message&&e.message.includes("URL already exists"))return{success:!1,error:"该网址已经被收藏过了",message:"该网址已经被收藏过了"};if(e instanceof Error&&e.message.includes("Network"))return await this.queueForLaterSync(t),{success:!0,offline:!0,message:"已暂存,将在网络恢复后同步"};throw e}}async updateTagCounts(t){for(const e of t){const o=await i.tags.where("name").equals(e).first();o&&o.id?await i.tags.update(o.id,{count:(o.count||0)+1}):await i.tags.add({name:e,count:1,createdAt:Date.now()})}}async queueForLaterSync(t){await i.metadata.add({key:`pending_${Date.now()}`,value:t,updatedAt:Date.now()}),console.log("[BookmarkService] Bookmark queued for later sync")}async syncPendingBookmarks(){const t=await i.metadata.where("key").startsWith("pending_").toArray();let e=0;for(const o of t)try{await k.addBookmark(o.value),await i.metadata.delete(o.key),e++,console.log("[BookmarkService] Synced pending bookmark:",o.value.title)}catch(a){console.error("[BookmarkService] Failed to sync pending bookmark:",a)}return console.log(`[BookmarkService] Synced ${e}/${t.length} pending bookmarks`),e}async getPendingCount(){return await i.metadata.where("key").startsWith("pending_").count()}}const _=new F;console.log("[Background] Service worker started");y.preloadContext().catch(r=>{console.error("[Background] Failed to preload AI context:",r)});chrome.runtime.onInstalled.addListener(async r=>{console.log("[Background] Extension installed:",r.reason),r.reason==="install"?console.log("[Background] First time install"):r.reason==="update"&&console.log("[Background] Extension updated")});function K(){const r=new Date,t=new Date(r);return t.setHours(23,0,0,0),t<=r&&t.setDate(t.getDate()+1),t.getTime()-r.getTime()}async function L(){try{const r=await g.loadConfig();if(!r.preferences.autoSync)return;console.log("[Background] Running scheduled auto-sync (23:00)...");const t=await E.autoSync(r.preferences.syncInterval);t&&console.log("[Background] Auto-sync result:",t)}catch(r){console.error("[Background] Auto-sync failed:",r)}}async function O(){const r=()=>{const t=K();console.log("[Background] Next auto-sync scheduled in",Math.round(t/1e3),"seconds"),setTimeout(async()=>{await L(),r()},t)};r()}O().catch(console.error);_.syncPendingBookmarks().catch(console.error);chrome.runtime.onMessage.addListener((r,t,e)=>($(r).then(o=>e(o)).catch(o=>{console.error("[Background] Message handler error:",o),e({success:!1,error:o instanceof Error?o.message:"Unknown error"})}),!0));async function $(r,t){switch(console.log("[Background] Received message:",r.type),r.type){case"EXTRACT_PAGE_INFO":{const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!e.id)throw new Error("No active tab");try{return await chrome.tabs.sendMessage(e.id,r)}catch(o){console.error("[Background] Failed to send message to content script:",o);try{return await chrome.scripting.executeScript({target:{tabId:e.id},files:["assets/content.js"]}),await new Promise(s=>setTimeout(s,100)),await Promise.race([chrome.tabs.sendMessage(e.id,r),new Promise((s,n)=>setTimeout(()=>n(new Error("Message timeout")),v.CONTENT_SCRIPT_INJECTION))])}catch(a){console.error("[Background] Failed to inject content script:",a);try{const s=await chrome.tabs.get(e.id),n=s.url||"";return{success:!0,data:{title:s.title||"Untitled",url:n,description:"",content:"",thumbnail:""}}}catch{throw new Error("Failed to extract page info: Unable to access tab information")}}}}case"RECOMMEND_TAGS":{const e=r.payload;return{success:!0,data:await y.recommendTags(e)}}case"SAVE_BOOKMARK":{const e=r.payload;return{success:!0,data:await _.saveBookmark(e)}}case"SYNC_CACHE":{const e=await E.fullSync();return{success:e.success,data:e,error:e.error}}case"GET_EXISTING_TAGS":try{return{success:!0,data:await k.getTags()}}catch(e){return console.error("[Background] Failed to get existing tags:",e),{success:!1,error:e instanceof Error?e.message:"Failed to load tags"}}case"GET_CONFIG":return{success:!0,data:await g.loadConfig()};case"CAPTURE_SNAPSHOT":{const{bookmarkId:e}=r.payload;if(!e)return{success:!1,error:"Bookmark ID is required"};const o=await P.captureAndUpload(e);return{success:o.success,data:o.success?{snapshotId:o.snapshotId,version:o.version}:void 0,error:o.error}}case"CHECK_EXISTING_BOOKMARK":{const{url:e}=r.payload;if(!e)return{success:!1,error:"URL is required"};try{const o=await k.findBookmarkByUrl(e);return{success:!0,data:{exists:!!o,bookmarkId:o?.id||null,bookmarkTitle:o?.title||null}}}catch(o){return console.error("[Background] Failed to check existing bookmark:",o),{success:!0,data:{exists:!1,bookmarkId:null,bookmarkTitle:null}}}}default:throw new Error(`Unknown message type: ${r.type}`)}}chrome.action.onClicked.addListener(async r=>{console.log("[Background] Extension icon clicked for tab:",r.id)});console.log("[Background] Service worker initialized");
