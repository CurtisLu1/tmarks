class i extends Error{constructor(t,e,r,s,a){super(e),this.code=t,this.status=r,this.details=s,this.retryAfter=a,this.name="TMarksAPIError"}isAuthError(){return["MISSING_API_KEY","INVALID_API_KEY","INSUFFICIENT_PERMISSIONS"].includes(this.code)}isRateLimitError(){return this.code==="RATE_LIMIT_EXCEEDED"}isNotFoundError(){return this.code==="NOT_FOUND"}isDuplicateError(){return["DUPLICATE_URL","DUPLICATE_TAG"].includes(this.code)}isServerError(){return this.status>=500}}class c{apiKey;baseUrl;rateLimitInfo=null;constructor(t){this.apiKey=t.apiKey,this.baseUrl=t.baseUrl||"https://tmarks.makeliving.fun/api"}getRateLimitInfo(){return this.rateLimitInfo}isNearRateLimit(t=.2){return this.rateLimitInfo?this.rateLimitInfo.remaining/this.rateLimitInfo.limit<t:!1}getRateLimitResetTime(){return this.rateLimitInfo?new Date(this.rateLimitInfo.reset*1e3):null}async request(t,e={}){const r=`${this.baseUrl}${t}`,s={"X-API-Key":this.apiKey,"Content-Type":"application/json",...e.headers};try{const a=await fetch(r,{...e,headers:s});if(this.extractRateLimitInfo(a),a.status===204)return;const o=await a.json();return a.ok||this.handleErrorResponse(a.status,o),o}catch(a){throw a instanceof i?a:a instanceof TypeError?new i("NETWORK_ERROR","Network error: Unable to connect to TMarks API",0,{originalError:a}):new i("UNKNOWN_ERROR",a instanceof Error?a.message:"Unknown error occurred",0,{originalError:a})}}async get(t,e){const r=e?`?${new URLSearchParams(this.cleanParams(e)).toString()}`:"";return this.request(`${t}${r}`,{method:"GET"})}async post(t,e){return this.request(t,{method:"POST",body:e?JSON.stringify(e):void 0})}async patch(t,e){return this.request(t,{method:"PATCH",body:JSON.stringify(e)})}async delete(t,e){return this.request(t,{method:"DELETE",body:e?JSON.stringify(e):void 0})}extractRateLimitInfo(t){const e=t.headers.get("X-RateLimit-Limit"),r=t.headers.get("X-RateLimit-Remaining"),s=t.headers.get("X-RateLimit-Reset");e&&r&&s&&(this.rateLimitInfo={limit:parseInt(e,10),remaining:parseInt(r,10),reset:parseInt(s,10)})}handleErrorResponse(t,e){const{code:r,message:s,details:a,retry_after:o}=e.error;throw new i(r,s,t,a,o)}cleanParams(t){const e={};for(const[r,s]of Object.entries(t))s!=null&&(e[r]=String(s));return e}}class u extends c{async getBookmarks(t){return this.get("/bookmarks",t)}async createBookmark(t){return this.post("/bookmarks",t)}async getBookmark(t){return this.get(`/bookmarks/${t}`)}async updateBookmark(t,e){return this.patch(`/bookmarks/${t}`,e)}async deleteBookmark(t){return this.delete(`/bookmarks/${t}`)}async getAllBookmarks(t){const e=[];let r=null;do{const s=await this.getBookmarks({...t,page_cursor:r||void 0,page_size:t?.page_size||100});e.push(...s.data.bookmarks),r=s.data.meta.next_cursor}while(r);return e}async getBookmarksByTags(t,e){return this.getBookmarks({...e,tags:t.join(",")})}async searchBookmarks(t,e){return this.getBookmarks({...e,keyword:t})}async getPinnedBookmarks(t){return this.getBookmarks({...t,pinned:!0})}async getArchivedBookmarks(t){return this.getBookmarks({...t,archived:!0})}async pinBookmark(t){return this.updateBookmark(t,{is_pinned:!0})}async unpinBookmark(t){return this.updateBookmark(t,{is_pinned:!1})}async archiveBookmark(t){return this.updateBookmark(t,{is_archived:!0})}async unarchiveBookmark(t){return this.updateBookmark(t,{is_archived:!1})}}class g extends c{async getTags(){return this.get("/tags")}async createTag(t){return this.post("/tags",t)}async getTag(t){return this.get(`/tags/${t}`)}async updateTag(t,e){return this.patch(`/tags/${t}`,e)}async deleteTag(t){return this.delete(`/tags/${t}`)}async findTagByName(t){return(await this.getTags()).data.tags.find(s=>s.name.toLowerCase()===t.toLowerCase())||null}async createTagIfNotExists(t){try{return await this.createTag(t)}catch(e){if(e.code==="DUPLICATE_TAG"){const r=await this.findTagByName(t.name);if(r)return{data:{tag:r}}}throw e}}async getTagsByPopularity(){return(await this.getTags()).data.tags.sort((e,r)=>(r.bookmark_count||0)-(e.bookmark_count||0))}async getUnusedTags(){return(await this.getTags()).data.tags.filter(e=>(e.bookmark_count||0)===0)}async deleteUnusedTags(){const t=await this.getUnusedTags();let e=0;for(const r of t)try{await this.deleteTag(r.id),e++}catch(s){console.error(`Failed to delete tag ${r.id}:`,s)}return{deleted:e}}async prepareMergeTags(t,e){const[r,s]=await Promise.all([this.getTag(t),this.getTag(e)]);return{sourceTag:r.data.tag,targetTag:s.data.tag}}}class h extends c{async getMe(){return this.get("/me")}async search(t){return this.get("/search",t)}async quickSearch(t){return this.search({q:t,limit:20})}async getStats(){return(await this.getMe()).data.user.stats}async validateApiKey(){try{return await this.getMe(),!0}catch{return!1}}}class d extends c{async getTabGroups(t){return this.get("/v1/tab-groups",t)}async createTabGroup(t){return this.post("/v1/tab-groups",t)}async getTabGroup(t){return this.get(`/v1/tab-groups/${t}`)}async updateTabGroup(t,e){return this.patch(`/v1/tab-groups/${t}`,e)}async deleteTabGroup(t){return this.delete(`/v1/tab-groups/${t}`)}async getAllTabGroups(t){const e=[];let r=null;do{const s=await this.getTabGroups({...t,page_cursor:r||void 0,page_size:t?.page_size||100});e.push(...s.data.tab_groups),r=s.data.meta.next_cursor}while(r);return e}}class k{bookmarks;tags;user;tabGroups;constructor(t){this.bookmarks=new u(t),this.tags=new g(t),this.user=new h(t),this.tabGroups=new d(t)}getRateLimitInfo(){return this.bookmarks.getRateLimitInfo()}}function m(n){return new k(n)}export{m as c};
